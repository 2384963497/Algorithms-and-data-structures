## 02数据结构与算法

[toc]

---

## 散列表(哈希表)

### 哈希表的特点

-   输入域是无穷
-   输出与是有界的(所以哈希表无法避免哈希碰撞;冲突)
-   同一个输入仅对应一个输出
-   输出的结果具有 离散性 和 均匀性

*   它的增删改查的操作都是$O(1)$级别





---

## 树

###树的基本概念

*   <img src="D:\007MyRepository\Algorithms-and-data-structures\Note\images\image-20221104161214225.png" alt="image-20221104161214225" style="zoom:67%;" />
*   根节点
    *   没有父节点的节点；图中的A节点
    *   且树种的每个节点最多只能有一个父节点
*   叶子节点
    *   没有孩子节点的节点（度为零的节点）；图中的BCHIPQKLMN
*   树的深度(高度)
    *   即树的层数；图中的数深度为4
*   树的度
    *   一个节点的孩子节点的个数叫做节点的度；图中E节点的度为2，F节点的3
    *   树的度就是所有节点度最大的度；图中的树的度即为3
*   孩子节点、父节点

*   子树


###二叉树

*   二叉树：度不超过2的树
*   每个节点最多有两个节点；分别为左孩子、右孩子节点

### 满二叉树

*   如果一个二叉树每一层的节点个数都是最大值

### 完全二叉树

*   叶子节点只出现在最后一层；且最后一层的所有叶子节点集中在左侧
*   完全二叉树的高度是$O(logN)$

### 二叉排序树

*   一个数中的所有父节点 都能区分开左右两个子树
    *   比如在父节点的左侧都是小于等于父节点的 父节点的右树都是大有父节点的

### 二叉树的性质

*   i的父节点
    *   $(i-1)//2$
*   i的左节点
    *   $i*2+1$
*   i的右节点
    *   $i*2+2$
*   第i层上的最大子节点个数为
    *   $2^(i-1)$

*   深度为i的二叉树的最大节点中和为
    *   $2^i-1$

*   二叉树中度数为0的节点为N0，度数为2的节点为N2，则N0=N2+2

### 树的实现

*   



### 树的遍历

*   层次遍历

    *   队列; 广度优先；前中后序都是栈; 后序遍历

*   前序遍历(先序遍历)

    *   父节点在前

*   中序遍历

    *   父节点在中

*   后续遍历

    *   父节点在后

*   ```python
    # 层次遍历
    def breadth_travel(self):
        if self.root == None:
            print("树为空！！！")
            return 0
        tempQueue = deque()
        tempQueue.append(self.root)
        while tempQueue.__len__() > 0:
            temp = tempQueue.popleft()
            print(temp.item, end = '')
            if temp.lnode != None:
                tempQueue.append(temp.lnode)
            if temp.rnode != None:
                tempQueue.append(temp.rnode)
    
    # inorder 中序遍历
    def inorder_travel(self):
        if self.root == None:
            print("树为空！！！")
            return
        self.inorderFunc(self.root)
    def inorderFunc(self, node):
        if node == None:
            return
        self.inorderFunc(node.lnode)
        print(node.item, end = '')
        self.inorderFunc(node.rnode)
        
    # preorder 前序遍历
    def preorder_travel(self):
        if self.root == None:
            print("树为空！！！")
            return
        self.preorderFunc(self.root)
    
    def preorderFunc(self, node):
        if node == None:
            return
        print(node.item, end = '')
        self.preorderFunc(node.lnode)
        self.preorderFunc(node.rnode)
    
    
    
    # postorder 后序遍历
    def postorder_travel(self):
        if self.root == None:
            print("树为空！！！")
            return
        self.postorderFunc(self.root)
    def postorderFunc(self, node):
        if node == None:
            return
        self.postorderFunc(node.lnode)
        self.postorderFunc(node.rnode)
        print(node.item, end = '')
    
    ```





---

## 堆

*   大根堆
    *   是一颗完全二叉树；且所有的父节点都比孩子节点大
    *   一个子树的根节点是这棵树的最大值
*   小根堆
    *   是一颗完全二叉树；且所有的父节点都比孩子节点小
    *   一个子树的根节点是这棵树的最小值

*   `heapify`

    *   调整代价是$O(logN)$级别

    *   ```python
        		i = index #这里为起始的位置
                j = 2*i+1
                while j <= deep:
                    temp = j 
                    if j+1 <= deep and nli[j] < nli[j+1]:
                        temp = j+1
                    if nli[temp] < nli[i]:
                        temp = i  #temp保存的是局部父子间最大值的下标
                    if temp == i:
                        break
                    nli[i], nli[temp] = nli[temp], nli[i]
                    i = temp
                    j = i*2+1
       ```

*   `heapinsert`

    *   调整代价是$O(logN)$级别

    *   ```python
        for i in range(len(nli)):
                j = i 
                while j > 0:
                    # if nli[j] > nli[(j-1)//2]:  #升序的大根堆
                    if nli[j] < nli[(j-1)//2]:  #降序的小根堆
                        nli[j], nli[(j-1)//2] = nli[(j-1)//2], nli[j]
                        j =  (j-1)//2
                    else:
                        break
        ```



---

## 比较器

*   也称重载比较运算符

*   通过自定义的比较规则；实现拓宽一些排序算法的使用范围

*   运用实例

    *   问题描述

        *   ```
            题目描述
            设有 n 个正整数 a1…an，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。
            
            输入格式
            第一行有一个整数，表示数字个数 n。
            
            第二行有 n 个整数，表示给出的 n 个整数 ai。
            
            输出格式
            一个正整数，表示最大的整数
            
            输入输出样例
            输入 #1复制
            
            3
            13 312 343
            输出 #1复制
            
            34331213
            输入 #2复制
            
            4
            7 13 4 246
            输出 #2复制
            
            7424613
            ```

    *   实现代码

        *   ```python
            #比较器
            def myCmp(a, b):
                if a+b > b+a:
                    return 1
                return 0
            
            #任意排序
            def mySort(nList):
                lLen = len(nList)
            
                for i in range(lLen):#heapInsert生成小根堆
                    j = i 
                    while j > 0:
                        if myCmp(nList[j], nList[(j-1)//2]):
                            break
                        nList[j], nList[(j-1)//2] = nList[(j-1)//2], nList[j]
                        j = (j-1)//2
                #heapify
                lLen -= 1
                while lLen > 0:
                    nList[0], nList[lLen] = nList[lLen], nList[0]
                    lLen -= 1
            
                    i = 0
                    j = 2*i+1
                    while j <= lLen:
                        temp = j
                        if j+1 <= lLen and not myCmp(nList[j+1], nList[j]):
                            temp = j+1
                        if not myCmp(nList[i], nList[temp]):
                            temp = i
                        if i == temp:
                            break
                        nList[i], nList[temp] = nList[temp], nList[i]
                        i = temp
                        j = i*2+1
                return nList
            
            n = int(input(""))
            nList = [None for i in range(n)]
            nList = input("").split(' ')
            
            nList = mySort(nList)
            
            s=''
            for i in nList:
                s+=i
            print(s)
            ```

        *   







---

## 单词

-   heap  堆

*   breadth  广度
*   depth  深度

































---

