# 09双指针

[toc]

---

## 总体思想与技巧

-   双指针可以分为快慢指针和双向指针
    -   快慢指针多用于链表的操作(同向)(滑动窗口)
    -   双向指针多用于字符串的操作(相向)
    -   还有背向双指针

---

## leetCode141 判断链表成环

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/linked-list-cycle/)

-   解题思路

    -   快慢指针
    -   快指针每次走两步
    -   慢指针每次走一步
    -   如果两个指针相遇则有换；如果快指针走到空，证明无环

-   实现代码

    -   ```python
        class Solution:
            def hasCycle(self, head: Optional[ListNode]) -> bool:
                if head == None or head.next == None:
                    return False
                fast = slow = head
                
                while fast != None:
                    fast = fast.next
                    if fast != None:
                        fast = fast.next
                    else:
                        return False
                    slow = slow.next
                    if slow == fast:
                        return True
        ```





---

## leetCode142 判断链表成环II

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/linked-list-cycle-ii/)
    *   找出入环点

-   解题思路
    -   快慢指针；如果两个指针相遇；
    -   一个指针回到头节点；两个指针同步前进
    -   两个指针相遇的第一个节点就是入环节点

-   实现代码

    -   ```python
        class Solution:
            def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
                if head == None or head.next == None:
                    return None
                fast = slow = head
                flag = False
                
                while fast != None:
                    fast = fast.next
                    if fast != None:
                        fast = fast.next
                    slow = slow.next
                    if slow == fast:
                        flag = True
                        break
                    
                if flag == False:
                    return None
                fast = head
                while fast != slow:
                    fast = fast.next
                    slow = slow.next
                return fast
        ```

---

## leetCode160 两链表相交

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

-   解题思路_抖机灵

    -   两个指针从分别从两个链表头节点出发同步前进;
    -   如果其中一个指针到了None，则指向另一个链表的头，两指针继续同步前进
    -   直到两个指针相遇；相遇的节点即为相交的第一个点；如果两个值同时为None则说明两链表不相交
    -   <img src="images/image-20221218214737321.png" alt="image-20221218214737321" style="zoom:50%;" />

-   实现代码

    -   ```python
        class Solution:
            def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
                if headA == None or headB == None:
                    return None
                nodeA = headA
                nodeB = headB
                
                while nodeA != nodeB:
                    if nodeA != None:
                        nodeA = nodeA.next
                    else:
                        nodeA = headB
                    
                    if nodeB != None:
                        nodeB = nodeB.next
                    else:
                        nodeB = headA
                return nodeA
        ```

-   解题思路

    -   分别遍历两个链表；并记录两个链表的长度
    -   判断两个链表的尾节点是否相同；相同证明两个链表一定相交，反之不相交；`l: 18`
    -   如果相等，则两个指针都指回各自的head；较长的链表指针走 两链表长度之差步数；
    -   使两个指针同步向下；直到遇到的第一个相同节点就是第一个交点

-   实现代码

    -   ```python
        class Solution:
            def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
                if headA == None or headB == None:
                    return None
                nodeA = headA
                nodeB = headB
                
                lenA = 1
                while nodeA.next != None:
                    nodeA = nodeA.next
                    lenA += 1
        
                lenB = 1
                while nodeB.next != None:
                    nodeB = nodeB.next
                    lenB += 1
                
                if nodeA != nodeB:
                    return None
                if lenA > lenB:
                    nodeA = headA
                    for i in range(lenA - lenB):
                        nodeA = nodeA.next
                    nodeB = headB
                else:
                    nodeB = headB
                    for i in range(lenB - lenA):
                        nodeB = nodeB.next
                    nodeA = headA
                
                while nodeA != nodeB:
                    nodeA = nodeA.next
                    nodeB = nodeB.next
                return nodeA
        ```

---

## leetCode19 删除链表倒数第N节点

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

-   解题思路

    -   快慢指针；让其中一个指针先走N步
    -   然后两个指针同步前进；当提前走的那个指针走到None, 此时另一个指针就是倒数第N个位置

-   实现代码

    -   ```python
        class Solution:
            def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
                if head.next == None:
                    head = None
                    return head
                # 以下情况均为大于等于二节点的情况
                end = head
                for i in range(n):
                    end = end.next
                
                cur = head
                while end != None:
                    pre = cur 
                    cur = cur.next
                    end = end.next
                if cur == head:
                    head = head.next
                else:
                    pre.next = cur.next
                return head
        ```



---

## leetCode21 merge两个链表

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/merge-two-sorted-lists/)

*   解题思路

    *   节点采摘法

*   实现代码

    *   ```python
        class Solution:
            def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
                if list1 == None:
                    return list2
                elif list2 == None:
                    return list1
                
                cur1 = list1
                cur2 = list2
        
                if cur1.val < cur2.val:
                    newHead = cur1
                    cur1 = cur1.next
                else:
                    newHead = cur2
                    cur2 = cur2.next
        
                curNew = newHead
                while cur1 and cur2:
                    if cur1.val < cur2.val:
                        curNew.next = cur1
                        cur1 = cur1.next
                    else:
                        curNew.next = cur2
                        cur2 = cur2.next
                    curNew = curNew.next
                
                curNew.next = cur1 if cur1 != None else cur2
                
                return newHead
        ```

---

## leetCode23 merge多个链表

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/merge-k-sorted-lists/)

*   解题思路_1

    *   可以分别两两merge直到最后只剩一个链表；返回即可

*   实现代码

    *   ```python
        class Solution:
            def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
                def mergeTwoLists(list1, list2):
                    if list1 == None:
                        return list2
                    elif list2 == None:
                        return list1
                    
                    cur1 = list1
                    cur2 = list2
        
                    if cur1.val < cur2.val:
                        newHead = cur1
                        cur1 = cur1.next
                    else:
                        newHead = cur2
                        cur2 = cur2.next
        
                    curNew = newHead
                    while cur1 and cur2:
                        if cur1.val < cur2.val:
                            curNew.next = cur1
                            cur1 = cur1.next
                        else:
                            curNew.next = cur2
                            cur2 = cur2.next
                        curNew = curNew.next
                    
                    curNew.next = cur1 if cur1 != None else cur2
                    return newHead
        
                if len(lists) == 0:
                    return None
        
                while len(lists) != 1:
                    a = lists.pop()
                    b = lists.pop()
                    lists.append(mergeTwoLists(a, b))
                return lists[0]
        ```




-   解题思路_堆

    -   先将所有的节点值都放入一个小根堆中，再依次取出，最后连成链表并返回
    -   在最后生成链表的时候，小技巧是先定义一个零时表头，最后零时表头的next即为最终的链表`l:16-23`

-   实现代码

    -   ```python
        class Solution:
            def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
                if len(lists) == 0:
                    return None
        
                import heapq
                
                h = []
                for i in lists:
                    if i:
                        j = i
                        while j:
                            heapq.heappush(h, j.val)
                            j = j.next
                        
                res = ListNode()
                cur = res
                while len(h) != 0:
                        temp = ListNode(heapq.heappop(h))
                        cur.next = temp
                        cur = cur.next
        
                return res.next
        ```





---

## leetCode86 分隔链表

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/partition-list/)

-   解题思路_1

    -   思路和荷兰国旗问题一样，准备一个指针遍历链表，另一个指针标记小于目标值的部分上界

    

-   解题思路_2

    -   准备两个零时表头，将小于target的串在一个链表中，大于等于的放另一个链表中，最后将两个链表串连

-   实现代码

    -   ```python
        class Solution:
            def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
                if head == None:
                    return head
        
                big = ListNode()
                bigp = big
                small = ListNode()
                smallp = small
        
                cur = head
                while cur != None:
                    if cur.val < x:
                        smallp.next = cur
                        cur = cur.next
                        smallp = smallp.next
                        smallp.next = None
                    else:
                        bigp.next = cur
                        cur = cur.next
                        bigp = bigp.next
                        bigp.next = None
                
                smallp.next = big.next
        
                return small.next
        ```



---

## leetCode876 链表中点

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/middle-of-the-linked-list/)

-   解题思路

    -   快慢指针，慢的走一步，快的走两步；当快指针走到空时，慢指针指到中点

-   实现代码

    -   ```python
        class Solution:
            def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
                if head.next == None:	
                    return head
                slow = fast = head
                while fast and fast.next != None:
                    fast = fast.next.next
                    slow = slow.next
                    
                return slow
        ```

---

## 滑动窗口思想与技巧

-   思路代码

    -   ```python
        need = collections.Counter(target)
        left = right = 0
        
        window = dict()
        # 存储当前窗口信息
        
        while right < len(s):
            # 窗口从右侧滑入一个字符
            temp = s[right]
            ...
            window[temp] = window.get(temp, 0 ) + 1
            # 收缩窗口
            while # 特定条件:
            	...
            	
                # 滑出窗口
                temp = s[left]
                window[temp] -= 1
                left += 1
            	...
            
            right += 1
        
        ```



---

## leetCode76 最小覆盖子串

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/minimum-window-substring/)

-   解题思路
    -   维护一个从左往右的窗口；当发现一个可行解之后开始尝试收缩窗口，优化可行解直到最优解

-   实现代码

    -   ```python
        class Solution:
            def minWindow(self, s: str, t: str) -> str:
                if len(t) > len(s):
                    return ''
                import collections
        
                need = collections.Counter(t)
                needLen = len(t)
        
                start = end = None
                left = right = 0
                while right < len(s):
                    # 滑入窗口
                    temp = s[right]
                    if temp in t:
                        need[temp] -= 1
                        if need[temp] >= 0:
                            needLen -= 1
        
                    # 判断是否能收缩当前有效解窗口
                    while needLen == 0:
                        if start == None or end - start > right - left:
                            start = left
                            end = right
                        # 滑出
                        temp = s[left]
                        if temp in t:
                            need[temp] += 1
                            if need[temp] > 0:
                                needLen += 1
                        left += 1
                    right += 1
                
                if start == None:
                    return ''
                return s[start:end + 1]
        ```



---

## leetCode567 字符串的排列

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/permutation-in-string/)

-   解题思路

    -   维护一个大小等于s1的窗口，在s2中遍历一次；判断是否存在一个窗口中包涵所有的字母

-   实现代码

    -   ```python
        class Solution:
            def checkInclusion(self, s1: str, s2: str) -> bool:
                import collections
                if len(s1) > len(s2):
                    return False
                left = 0
                right = left + len(s1) - 1
                # 窗口大小
                need = collections.Counter(s1)
        
                
        
                while right < len(s2):
                    if s2[left] in s1 and s2[right] in s1:
                        temp = collections.Counter(s2[left:right + 1])
                        if temp == need:
                            return True
                    left += 1
                    right += 1
                return False
        ```

---

## leetCode438 找到字符串中所有字母异位词

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

-   解题思路

    -   思路大致与上一题一致

-   实现代码

    -   ```python
        class Solution:
            def findAnagrams(self, s: str, p: str) -> List[int]:
                if len(p) > len(s):
                    return []
        
                import collections 
                need = collections.Counter(p)
                needLen = len(need)
                window = dict()
                res = []
                
                left = right = 0
                while right < len(s):
                    # 滑入
                    temp = s[right]
                    if temp in p:
                        window[temp] = window.get(temp, 0) + 1
                        if window[temp] == need[temp]:
                            needLen -=1
        			# punchline 
                    # 要分清楚收缩窗口的条件，使得每一次进行内层判断的窗口大小都是固定的
                    while right - left + 1 >= len(p):
                        if needLen == 0:
                            res.append(left)
                        
                        # 滑出
                        temp = s[left]
                        if temp in need:
                            if window[temp] == need[temp]:
                                needLen += 1
                            window[temp] -= 1
                        left += 1
                    right += 1
                return res
        ```





---

## leetCode3 无重复字符的最长子串

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

-   解题思路_双指针

    -   每次滑入一个字符，判断这个字符是否与前面的重复；
    -   如果不重复就判断并更新res，如果存在则缩小窗口直到窗口中再无重复字符，再进行下一次扩大窗口




-   实现代码

    -   ```python
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                if s == '':
                    return 0
                left = right = 0
                nowSet = set()
                res = -1
        
                while right < len(s):
                    # 滑入
                    temp = s[right]
                    if temp not in nowSet:
                        nowSet.add(temp)
                        res = res if res > len(nowSet) else len(nowSet)
                    # 收缩
                    else:
                        while s[left] != s[right]:
                            temp = s[left]
                            nowSet.remove(temp)
                            left += 1
                        left += 1
                    right += 1
                return res
        ```

-   解题思路_DP

    -   分别讨论以每个位置结尾的情况下最长无重复子串的最大长度
    -   那么就要思考前面的DP信息如何加速当前位置的查询；
    -   假设DP[i - 1]位置上的信息已经正确获取到，如果当前位置的字符之前没出现过那么当前DP[i] = DP[i - 1] + 1; 
    -   如果出现过那么就要讨论当前字符出现的前一次位置是否穿插在DP[i - 1]中，如果是那么DP[i] = i - meme[s[i]]
    -   如果没有穿插在DP[i - 1]结尾的字符串中，则DP[i] = DP[i - 1] + 1

-   实现代码

    -   ```python
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                if s == '':
                    return 0
                memo = dict()
                temp = 0
                res = -1
        
                for i in range(len(s)):
                    # DP[i - 1]
                    if memo.get(s[i]) == None:
                        # 前面出现过当前字符
                        temp = temp + 1
                    else:
                        if temp < i - memo[s[i]]:
                            # 当前字符出现的前一个位置不在考虑范围内
                            temp = temp + 1
                        else:
                            # 不能直接引用temp的值
                            temp = i - memo[s[i]]
                    res = max(res, temp)
                    memo[s[i]] = i
                return res
        ```

    -   空间复杂度也是O(1) 时间复杂度同样为O(N)




---

## 绳子覆盖最多的点

*   问题描述
    *   [问题地址](https://www.bilibili.com/video/BV1M44y1n78z?p=45&vd_source=ee0039310b856bf5ae81ddf4118b5a6b)
    *   给定一个有序数组arr，代表坐落在X轴上的点给定一个正数K，代表绳子的长度
        返回绳子最多压中几个点?
        即使绳子边缘处盖住点也算盖住

*   解题思路

    *   **贪心: 在最优解的情况下，绳子的末位点或者起始点一定压在数组中存在的点上**
    *   所以根据起始点或者末位点进行贪心；
    *   如果以开头点作为贪心那么就分别讨论以每个点作为开头的情况下，绳子向右延升最多能覆盖住几个点，最后返回
    *   滑动窗口思想：定义左右指针一开始都指向第一个点，窗口向右侧扩大，如果L 和 R之间的距离大于了绳子长度就进行左侧窗口的收缩
    *   如果当前窗口合法，那么就计算当前窗口内的有效点并更新最大值
    *   先让窗口向右扩大，然后将窗口收缩到合法大小，再在这个合法的窗口上尝试更新最优解

*   实现代码

    *   ```python
        def func1(arr, K):
            maxLen = -1
            left = 0
            now = 0 # 当期窗口内的合法点
            res = -1
            
            ###先让窗口向右扩大，然后将窗口收缩到合法大小，再在这个合法的窗口上尝试更新最优解
            for right in range(len(arr)):
                # 窗口向右扩大一个点	
                now += 1
        
                while arr[right] - arr[left] > K:
                    # 需要收缩当前窗口
                    left += 1
                    now -= 1
                # 经过上面的循环后的窗口必定合法
                if maxLen < now:
                    maxLen = now
                    res = left
            print(maxLen, res)
        ```

---

## 分类'G'和'B '

-   问题描述
    -   一个数组中只有两种字符'G'和'B’，
    -   想让所有的G都放在左侧，所有的B都放在右侧 **或者** G在右边，B在左边(目的分离BG)
    -   **但是只能在相邻字符之间进行交换操作**，返回至少需要交换**几次**

*    解题思路

    *   贪心：从左往右出现的第一个G一定在最终的结果中出现在0位置，第二个G出现在1位置，
    *   因为前面的G没有任何理由和必要和后面的G交换(因为交换只出现在两个相邻的字符之间)

    -   定义两个指针，第一个指针从左往右搜索**下一个G应该交换到的位置**，第二个**指针搜索下个G的位置**，他们之间的距离就是交换的代价次数
    -   当第二个指针走到最后，证明字符串中的所有G已经全在左侧，那么B就自然全在右侧

*   实现代码

    *   ```python
        s = 'BBBBBBGGBGGB'
        
        hold1 = 0
        hold2 = 0
        count1 = 0
        count2 = 0
        
        for index in range(len(s)):
            if s[index] == 'G':
                count1 += index - hold1
                hold1 += 1
            if s[index] == 'B':
                count2 += index - hold2
                hold2 += 1
        
        print(count1, count2) 
        print(min(count1, count2)) 
        ```



---

## leetCode42 接雨水I

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/trapping-rain-water/)

*   解题思路

    *   观察一个位置最终的接得的水量，是取决于它左侧最大值和右侧最大值，是它们之中较小的那个
    *   最两边的位置不可能有水
    *   可以先从左往右计算不考虑右侧的情况下，当前单元格能接得的水量；因为一个方向所以左侧的最大值可以不停维护得到
    *   再从右往左计算这个方向上的水量，当前位置的最终水量是两个方向上水量的较小者
    *   最终每个位置求和

*   实现代码

    *   ```python
        class Solution:
            def trap(self, height: List[int]) -> int:
                N = len(height)
                if N <= 2:
                    return 0
                
                # 先从左往右
                Max = height[0]
                temp = [0] * N
                for i in range(1, N - 1):
                    if height[i] > Max:
                        Max = height[i]
                    else:
                        temp[i] = Max - height[i]
                
                Max = height[-1]
                for i in range(N - 2, -1, -1):
                    if height[i] > Max:
                        Max = height[i]
                        temp[i] = 0
                    else:
                        temp[i] = min(temp[i], Max - height[i])
                
                return sum(temp)
        ```

*   解题思路_双指针

    *   解题的依据和上述方法一样，就是判断一个位置左右两侧最大值和当前位置的大小关系，结算每个位置的水量最后求和
    *   左右指针分别指向首元素和结尾元素，移动两个元素中较小的一个，并结算移动后位置的水量，在指针移动的过程中要维护两个方向的最值

*   实现代码

    *   ```python
        class Solution:
            def trap(self, height: List[int]) -> int:
                N = len(height)
                if N <= 2:
                    return 0
        
                left = 0
                right = N - 1
                lMax = height[0]
                rMax = height[-1]
                temp = [0] * N
        
                while right - left > 1:
                    if height[left] < height[right]:
                        temp[left + 1] = max(0, lMax - height[left + 1])
                        lMax = max(lMax, height[left + 1])
                        left += 1
                    else:
                        temp[right - 1] = max(0, rMax - height[right - 1])
                        rMax = max(rMax, height[right - 1])
                        right -= 1
                
                return sum(temp)
        ```





---

## leetCode407 接雨水II

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/trapping-rain-water-ii/)

*   解题思路

    *   先将四周的点依次加入堆中去，同时带上自己的行列信息；
    *   维护一个遍历tempMax它表示的是当前墙最低点，墙的瓶颈
    *   从堆中弹出墙中最低点，看它能否让现有瓶颈变大`l:36`
    *   然后结算他的上下左右四个点，因为如果四个点存在且小于当前点，那么它们最多能接的水就是当前瓶颈 - 它们自身高度`l:48`，大于瓶颈则没水，水必定从瓶颈方向流走
    *   将结算完的点加入堆中去，直到每个点都处理即堆中为空

*   实现代码

    *   ```python
        class Solution:
            def trapRainWater(self, heightMap: List[List[int]]) -> int:
                M = len(heightMap[0]) # col
                N = len(heightMap)  # row
                dir = ((0, 1), (0, -1), (-1, 0), (1, 0))
                if N <= 2:
                    return 0
        
                import heapq
                heap = []
                # 标记是否处理过的数组
                used = [[False for j in range(M)] for i in range(N)]
        
                # tempMax表示是当前为单元格所处墙内的瓶颈
                tempMax = -1
        
                res = 0
                # 先将最外面的一圈放入heap中去(其实四个角没必要放)
                for j in range(M):
                    heap.append((heightMap[0][j], 0, j))
                    used[0][j] = True
                    heap.append((heightMap[N - 1][j], N - 1, j))
                    used[N - 1][j] = True
        
                for i in range(1, N - 1):
                    heap.append((heightMap[i][0], i, 0))
                    used[i][0] = True
                    heap.append((heightMap[i][M - 1], i, M - 1))
                    used[i][M - 1] = True
        
                heapq.heapify(heap)
        
                # 依次处理每个点
                while heap != []:
                    tHeight, x, y = heapq.heappop(heap)
                    if tHeight > tempMax:
                        tempMax = tHeight
                    
                    # 拓展当前点
                    for dx, dy in dir:
                        # 入堆的条件是，下标不越界且没被处理过
                        tx = x + dx
                        ty = y + dy
                        if tx <= 0 or tx >= N - 1 or  ty <= 0 or ty >= M - 1 or used[tx][ty] == True:
                            continue
                        if heightMap[tx][ty] < tempMax:
                            # 可以结算当前拓展点
                            res += (tempMax - heightMap[tx][ty])
                        used[tx][ty] = True
                        heapq.heappush(heap, (heightMap[tx][ty], tx, ty))
        
                return res
        ```





---

## leetCode15 三数之和

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/3sum/)

*   解题思路

    *   先将数组排序；然后定义一个指针从左往右遍历(为了去重所以与前面字符相同的跳过)，在当前指针往后找是否能凑出当前值相反数的两数和
    *   求两数和方法：双指针；因为可能出现多对结果，所找到后left += 1，right -= 1知道left == right

*   实现代码

    *   ```python
        class Solution:
            def threeSum(self, nums: List[int]) -> List[List[int]]:
                nums.sort()
                if nums[-1] < 0 or nums[0] > 0:
                    return []
                res = []
        
                def towSum(target, beg):
                    left = beg
                    right = len(nums) - 1
                    
                    while left < right:
                        if nums[left] + nums[right] + target == 0:
                            res.append([nums[left], target, nums[right]])
        
                            left += 1
                            while left < right and nums[left] == nums[left - 1]:
                                left += 1
                            right -= 1
                            while right > left and nums[right] == nums[right + 1]:
                                right -= 1
                            
                        elif nums[left] + nums[right] + target > 0:
                            right -= 1
                        else:
                            left += 1
                
                for i in range(len(nums)):
                    if i > 0 and nums[i] == nums[i - 1]:
                        continue
                    towSum(nums[i], i + 1)
        
                return res
        ```



---

## leetCode16 最接近的三数之和

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/3sum-closest/)

*   解题思路

    *   做法与三数之和相近，不同的是在判断当前组合是否足够接近目标值时需要求当前和和目标值的绝对值，注意去重和指针移动即可

*   实现代码

    *   ```python
        class Solution:
            def threeSumClosest(self, nums: List[int], target: int) -> int:
                import sys
                nums.sort()
                
        
                def towSum(tTarget, beg, tGap):
                    tRes = None
                    left = beg
                    right = len(nums) - 1
                    while left < right:
                        nowSum = nums[left] + nums[right]
                        nowGap = abs(tTarget - nowSum)
                        if tGap > nowGap:
                            tGap = nowGap
                            tRes = nowSum
            
                        if nowGap == 0:
                            return 0, nowSum
        
                        if nowSum > tTarget:
                            right -= 1
                            while right > left and nums[right] == nums[right + 1]:
                                right -= 1
                        else:
                            left += 1
                            while left < right and nums[left - 1] == nums[left]:
                                left += 1
        
                    return tGap, tRes
                    
        
                gap = sys.maxsize
                res = None
                for i in range(len(nums) - 2):
                    if i - 1 >= 0 and nums[i] == nums[i - 1]:
                        continue
                    tGap, tRes = towSum(target - nums[i], i + 1, gap)
                    if gap > tGap:
                        gap = tGap
                        res = tRes + nums[i]
                    if gap == 0:
                        res = target
                        break
                return res
        ```





---

## leetCode18 四数之和

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/4sum/)

*   解题思路

    *   思路和两数之和、三数之和一样

*   实现代码

    *   ```python
        class Solution:
            def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
                nums.sort()
                if len(nums) < 4:
                    return []
                N = len(nums)
                
                def towSum(tTarget, pre1, pre2, left):
                    
                    right = N - 1
                    lMove = False
                    rMove = False
        
                    while left < right:
                        if nums[left] + nums[right] == tTarget:
                            res.append([pre1, pre2, nums[left], nums[right]])
                            lMove = True
                            rMove = True
                        elif nums[left] + nums[right] > tTarget:
                            rMove = True
                        else:
                            lMove = True
        
                        if lMove:
                            left += 1
                            while left < right and nums[left] == nums[left - 1]:
                                left += 1
                            lMove = False
                        if rMove:
                            right -= 1
                            while right > left and nums[right] == nums[right + 1]:
                                right -= 1
                            rMove = False
        
                    return res
                
                def threeSum(tTarget, pre1, left):
                    for i in range(left, N - 2):
                        if i > left and nums[i] == nums[i - 1]:
                            continue
                        towSum(tTarget - nums[i], pre1, nums[i], i + 1)
                    return res
                
                res = []
                for i in range(N - 3):
                    if i > 0 and nums[i] == nums[i - 1]:
                        continue
                    threeSum(target - nums[i], nums[i], i + 1)
                
                return res
        ```













## leetCode

-   问题描述
    -   [问题地址]()















































---

## leetCode

*   问题描述
    *   [问题地址]()



