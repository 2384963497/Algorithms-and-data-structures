# 09双指针&二分

[toc]

---

## 总体思想与技巧

-   双指针可以分为快慢指针和双向指针
    -   快慢指针多用于链表的操作(同向)(滑动窗口)
    -   双向指针多用于字符串的操作(相向)
    -   还有背向双指针

---

## leetCode141 判断链表成环

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/linked-list-cycle/)

-   解题思路

    -   快慢指针
    -   快指针每次走两步
    -   慢指针每次走一步
    -   如果两个指针相遇则有换；如果快指针走到空，证明无环

-   实现代码

    -   ```python
        class Solution:
            def hasCycle(self, head: Optional[ListNode]) -> bool:
                if head == None or head.next == None:
                    return False
                fast = slow = head
                
                while fast != None:
                    fast = fast.next
                    if fast != None:
                        fast = fast.next
                    else:
                        return False
                    slow = slow.next
                    if slow == fast:
                        return True
        ```





---

## leetCode142 判断链表成环II

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/linked-list-cycle-ii/)
    *   找出入环点

-   解题思路
    -   快慢指针；如果两个指针相遇；
    -   一个指针回到头节点；两个指针同步前进
    -   两个指针相遇的第一个节点就是入环节点

-   实现代码

    -   ```python
        class Solution:
            def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
                if head == None or head.next == None:
                    return None
                fast = slow = head
                flag = False
                
                while fast != None:
                    fast = fast.next
                    if fast != None:
                        fast = fast.next
                    slow = slow.next
                    if slow == fast:
                        flag = True
                        break
                    
                if flag == False:
                    return None
                fast = head
                while fast != slow:
                    fast = fast.next
                    slow = slow.next
                return fast
        ```

---

## leetCode160 两链表相交

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

-   解题思路_抖机灵

    -   两个指针从分别从两个链表头节点出发同步前进;
    -   如果其中一个指针到了None，则指向另一个链表的头，两指针继续同步前进
    -   直到两个指针相遇；相遇的节点即为相交的第一个点；如果两个值同时为None则说明两链表不相交
    -   <img src="images/image-20221218214737321.png" alt="image-20221218214737321" style="zoom:50%;" />

-   实现代码

    -   ```python
        class Solution:
            def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
                if headA == None or headB == None:
                    return None
                nodeA = headA
                nodeB = headB
                
                while nodeA != nodeB:
                    if nodeA != None:
                        nodeA = nodeA.next
                    else:
                        nodeA = headB
                    
                    if nodeB != None:
                        nodeB = nodeB.next
                    else:
                        nodeB = headA
                return nodeA
        ```

-   解题思路

    -   分别遍历两个链表；并记录两个链表的长度
    -   判断两个链表的尾节点是否相同；相同证明两个链表一定相交，反之不相交；`l: 18`
    -   如果相等，则两个指针都指回各自的head；较长的链表指针走 两链表长度之差步数；
    -   使两个指针同步向下；直到遇到的第一个相同节点就是第一个交点

-   实现代码

    -   ```python
        class Solution:
            def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
                if headA == None or headB == None:
                    return None
                nodeA = headA
                nodeB = headB
                
                lenA = 1
                while nodeA.next != None:
                    nodeA = nodeA.next
                    lenA += 1
        
                lenB = 1
                while nodeB.next != None:
                    nodeB = nodeB.next
                    lenB += 1
                
                if nodeA != nodeB:
                    return None
                if lenA > lenB:
                    nodeA = headA
                    for i in range(lenA - lenB):
                        nodeA = nodeA.next
                    nodeB = headB
                else:
                    nodeB = headB
                    for i in range(lenB - lenA):
                        nodeB = nodeB.next
                    nodeA = headA
                
                while nodeA != nodeB:
                    nodeA = nodeA.next
                    nodeB = nodeB.next
                return nodeA
        ```

---

## leetCode19 删除链表倒数第N节点

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

-   解题思路

    -   快慢指针；让其中一个指针先走N步
    -   然后两个指针同步前进；当提前走的那个指针走到None, 此时另一个指针就是倒数第N个位置

-   实现代码

    -   ```python
        class Solution:
            def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
                if head.next == None:
                    head = None
                    return head
                # 以下情况均为大于等于二节点的情况
                end = head
                for i in range(n):
                    end = end.next
                
                cur = head
                while end != None:
                    pre = cur 
                    cur = cur.next
                    end = end.next
                if cur == head:
                    head = head.next
                else:
                    pre.next = cur.next
                return head
        ```



---

## leetCode21 merge两个链表

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/merge-two-sorted-lists/)

*   解题思路

    *   节点采摘法

*   实现代码

    *   ```python
        class Solution:
            def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
                if list1 == None:
                    return list2
                elif list2 == None:
                    return list1
                
                cur1 = list1
                cur2 = list2
        
                if cur1.val < cur2.val:
                    newHead = cur1
                    cur1 = cur1.next
                else:
                    newHead = cur2
                    cur2 = cur2.next
        
                curNew = newHead
                while cur1 and cur2:
                    if cur1.val < cur2.val:
                        curNew.next = cur1
                        cur1 = cur1.next
                    else:
                        curNew.next = cur2
                        cur2 = cur2.next
                    curNew = curNew.next
                
                curNew.next = cur1 if cur1 != None else cur2
                
                return newHead
        ```

---

## leetCode23 merge多个链表

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/merge-k-sorted-lists/)

*   解题思路_1

    *   可以分别两两merge直到最后只剩一个链表；返回即可

*   实现代码

    *   ```python
        class Solution:
            def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
                def mergeTwoLists(list1, list2):
                    if list1 == None:
                        return list2
                    elif list2 == None:
                        return list1
                    
                    cur1 = list1
                    cur2 = list2
        
                    if cur1.val < cur2.val:
                        newHead = cur1
                        cur1 = cur1.next
                    else:
                        newHead = cur2
                        cur2 = cur2.next
        
                    curNew = newHead
                    while cur1 and cur2:
                        if cur1.val < cur2.val:
                            curNew.next = cur1
                            cur1 = cur1.next
                        else:
                            curNew.next = cur2
                            cur2 = cur2.next
                        curNew = curNew.next
                    
                    curNew.next = cur1 if cur1 != None else cur2
                    return newHead
        
                if len(lists) == 0:
                    return None
        
                while len(lists) != 1:
                    a = lists.pop()
                    b = lists.pop()
                    lists.append(mergeTwoLists(a, b))
                return lists[0]
        ```




-   解题思路_堆

    -   先将所有的节点值都放入一个小根堆中，再依次取出，最后连成链表并返回
    -   在最后生成链表的时候，小技巧是先定义一个零时表头，最后零时表头的next即为最终的链表`l:16-23`

-   实现代码

    -   ```python
        class Solution:
            def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
                if len(lists) == 0:
                    return None
        
                import heapq
                
                h = []
                for i in lists:
                    if i:
                        j = i
                        while j:
                            heapq.heappush(h, j.val)
                            j = j.next
                        
                res = ListNode()
                cur = res
                while len(h) != 0:
                        temp = ListNode(heapq.heappop(h))
                        cur.next = temp
                        cur = cur.next
        
                return res.next
        ```





---

## leetCode86 分隔链表

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/partition-list/)

-   解题思路_1

    -   思路和荷兰国旗问题一样，准备一个指针遍历链表，另一个指针标记小于目标值的部分上界

    

-   解题思路_2

    -   准备两个零时表头，将小于target的串在一个链表中，大于等于的放另一个链表中，最后将两个链表串连

-   实现代码

    -   ```python
        class Solution:
            def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
                if head == None:
                    return head
        
                big = ListNode()
                bigp = big
                small = ListNode()
                smallp = small
        
                cur = head
                while cur != None:
                    if cur.val < x:
                        smallp.next = cur
                        cur = cur.next
                        smallp = smallp.next
                        smallp.next = None
                    else:
                        bigp.next = cur
                        cur = cur.next
                        bigp = bigp.next
                        bigp.next = None
                
                smallp.next = big.next
        
                return small.next
        ```



---

## leetCode876 链表中点

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/middle-of-the-linked-list/)

-   解题思路

    -   快慢指针，慢的走一步，快的走两步；当快指针走到空时，慢指针指到中点

-   实现代码

    -   ```python
        class Solution:
            def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
                if head.next == None:	
                    return head
                slow = fast = head
                while fast and fast.next != None:
                    fast = fast.next.next
                    slow = slow.next
                    
                return slow
        ```

---

## 滑动窗口思想与技巧

-   思路代码

    -   ```python
        need = collections.Counter(target)
        left = right = 0
        
        window = dict()
        # 存储当前窗口信息
        
        while right < len(s):
            # 窗口从右侧滑入一个字符
            temp = s[right]
            ...
            window[temp] = window.get(temp, 0 ) + 1
            # 收缩窗口
            while # 特定条件:
            	...
            	
                # 滑出窗口
                temp = s[left]
                window[temp] -= 1
                left += 1
            	...
            
            right += 1
        
        ```



---

## leetCode76 最小覆盖子串

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/minimum-window-substring/)

-   解题思路
    -   维护一个从左往右的窗口；当发现一个可行解之后开始尝试收缩窗口，优化可行解直到最优解

-   实现代码

    -   ```python
        class Solution:
            def minWindow(self, s: str, t: str) -> str:
                if len(t) > len(s):
                    return ''
                import collections
        
                need = collections.Counter(t)
                needLen = len(t)
        
                start = end = None
                left = right = 0
                while right < len(s):
                    # 滑入窗口
                    temp = s[right]
                    if temp in t:
                        need[temp] -= 1
                        if need[temp] >= 0:
                            needLen -= 1
        
                    # 判断是否能收缩当前有效解窗口
                    while needLen == 0:
                        if start == None or end - start > right - left:
                            start = left
                            end = right
                        # 滑出
                        temp = s[left]
                        if temp in t:
                            need[temp] += 1
                            if need[temp] > 0:
                                needLen += 1
                        left += 1
                    right += 1
                
                if start == None:
                    return ''
                return s[start:end + 1]
        ```



---

## leetCode567 字符串的排列

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/permutation-in-string/)

-   解题思路

    -   维护一个大小等于s1的窗口，在s2中遍历一次；判断是否存在一个窗口中包涵所有的字母

-   实现代码

    -   ```python
        class Solution:
            def checkInclusion(self, s1: str, s2: str) -> bool:
                import collections
                if len(s1) > len(s2):
                    return False
                left = 0
                right = left + len(s1) - 1
                # 窗口大小
                need = collections.Counter(s1)
        
                
        
                while right < len(s2):
                    if s2[left] in s1 and s2[right] in s1:
                        temp = collections.Counter(s2[left:right + 1])
                        if temp == need:
                            return True
                    left += 1
                    right += 1
                return False
        ```

---

## leetCode438 找到字符串中所有字母异位词

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

-   解题思路

    -   思路大致与上一题一致

-   实现代码

    -   ```python
        class Solution:
            def findAnagrams(self, s: str, p: str) -> List[int]:
                if len(p) > len(s):
                    return []
        
                import collections 
                need = collections.Counter(p)
                needLen = len(need)
                window = dict()
                res = []
                
                left = right = 0
                while right < len(s):
                    # 滑入
                    temp = s[right]
                    if temp in p:
                        window[temp] = window.get(temp, 0) + 1
                        if window[temp] == need[temp]:
                            needLen -=1
        			# punchline 
                    # 要分清楚收缩窗口的条件，使得每一次进行内层判断的窗口大小都是固定的
                    while right - left + 1 >= len(p):
                        if needLen == 0:
                            res.append(left)
                        
                        # 滑出
                        temp = s[left]
                        if temp in need:
                            if window[temp] == need[temp]:
                                needLen += 1
                            window[temp] -= 1
                        left += 1
                    right += 1
                return res
        ```





---

## leetCode3 无重复字符的最长子串

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

-   解题思路_双指针

    -   每次滑入一个字符，判断这个字符是否与前面的重复；
    -   如果不重复就判断并更新res，如果存在则缩小窗口直到窗口中再无重复字符，再进行下一次扩大窗口




-   实现代码

    -   ```python
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                if s == '':
                    return 0
                left = right = 0
                nowSet = set()
                res = -1
        
                while right < len(s):
                    # 滑入
                    temp = s[right]
                    if temp not in nowSet:
                        nowSet.add(temp)
                        res = res if res > len(nowSet) else len(nowSet)
                    # 收缩
                    else:
                        while s[left] != s[right]:
                            temp = s[left]
                            nowSet.remove(temp)
                            left += 1
                        left += 1
                    right += 1
                return res
        ```

-   解题思路_DP

    -   分别讨论以每个位置结尾的情况下最长无重复子串的最大长度
    -   那么就要思考前面的DP信息如何加速当前位置的查询；
    -   假设DP[i - 1]位置上的信息已经正确获取到，如果当前位置的字符之前没出现过那么当前DP[i] = DP[i - 1] + 1; 
    -   如果出现过那么就要讨论当前字符出现的前一次位置是否穿插在DP[i - 1]中，如果是那么DP[i] = i - meme[s[i]]
    -   如果没有穿插在DP[i - 1]结尾的字符串中，则DP[i] = DP[i - 1] + 1

-   实现代码

    -   ```python
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                if s == '':
                    return 0
                memo = dict()
                temp = 0
                res = -1
        
                for i in range(len(s)):
                    # DP[i - 1]
                    if memo.get(s[i]) == None:
                        # 前面出现过当前字符
                        temp = temp + 1
                    else:
                        if temp < i - memo[s[i]]:
                            # 当前字符出现的前一个位置不在考虑范围内
                            temp = temp + 1
                        else:
                            # 不能直接引用temp的值
                            temp = i - memo[s[i]]
                    res = max(res, temp)
                    memo[s[i]] = i
                return res
        ```

    -   空间复杂度也是O(1) 时间复杂度同样为O(N)




---

## 绳子覆盖最多的点

*   问题描述
    *   [问题地址](https://www.bilibili.com/video/BV1M44y1n78z?p=45&vd_source=ee0039310b856bf5ae81ddf4118b5a6b)
    *   给定一个有序数组arr，代表坐落在X轴上的点给定一个正数K，代表绳子的长度
        返回绳子最多压中几个点?
        即使绳子边缘处盖住点也算盖住

*   解题思路

    *   **贪心: 在最优解的情况下，绳子的末位点或者起始点一定压在数组中存在的点上**
    *   所以根据起始点或者末位点进行贪心；
    *   如果以开头点作为贪心那么就分别讨论以每个点作为开头的情况下，绳子向右延升最多能覆盖住几个点，最后返回
    *   滑动窗口思想：定义左右指针一开始都指向第一个点，窗口向右侧扩大，如果L 和 R之间的距离大于了绳子长度就进行左侧窗口的收缩
    *   如果当前窗口合法，那么就计算当前窗口内的有效点并更新最大值
    *   先让窗口向右扩大，然后将窗口收缩到合法大小，再在这个合法的窗口上尝试更新最优解

*   实现代码

    *   ```python
        def func1(arr, K):
            maxLen = -1
            left = 0
            now = 0 # 当期窗口内的合法点
            res = -1
            
            ###先让窗口向右扩大，然后将窗口收缩到合法大小，再在这个合法的窗口上尝试更新最优解
            for right in range(len(arr)):
                # 窗口向右扩大一个点	
                now += 1
        
                while arr[right] - arr[left] > K:
                    # 需要收缩当前窗口
                    left += 1
                    now -= 1
                # 经过上面的循环后的窗口必定合法
                if maxLen < now:
                    maxLen = now
                    res = left
            print(maxLen, res)
        ```

---

## 分类'G'和'B '

-   问题描述
    -   一个数组中只有两种字符'G'和'B’，
    -   想让所有的G都放在左侧，所有的B都放在右侧 **或者** G在右边，B在左边(目的分离BG)
    -   **但是只能在相邻字符之间进行交换操作**，返回至少需要交换**几次**

*    解题思路

    *   贪心：从左往右出现的第一个G一定在最终的结果中出现在0位置，第二个G出现在1位置，
    *   因为前面的G没有任何理由和必要和后面的G交换(因为交换只出现在两个相邻的字符之间)

    -   定义两个指针，第一个指针从左往右搜索**下一个G应该交换到的位置**，第二个**指针搜索下个G的位置**，他们之间的距离就是交换的代价次数
    -   当第二个指针走到最后，证明字符串中的所有G已经全在左侧，那么B就自然全在右侧

*   实现代码

    *   ```python
        s = 'BBBBBBGGBGGB'
        
        hold1 = 0
        hold2 = 0
        count1 = 0
        count2 = 0
        
        for index in range(len(s)):
            if s[index] == 'G':
                count1 += index - hold1
                hold1 += 1
            if s[index] == 'B':
                count2 += index - hold2
                hold2 += 1
        
        print(count1, count2) 
        print(min(count1, count2)) 
        ```



---

## leetCode42 接雨水I

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/trapping-rain-water/)

*   解题思路

    *   观察一个位置最终的接得的水量，是取决于它左侧最大值和右侧最大值，是它们之中较小的那个
    *   最两边的位置不可能有水
    *   可以先从左往右计算不考虑右侧的情况下，当前单元格能接得的水量；因为一个方向所以左侧的最大值可以不停维护得到
    *   再从右往左计算这个方向上的水量，当前位置的最终水量是两个方向上水量的较小者
    *   最终每个位置求和

*   实现代码

    *   ```python
        class Solution:
            def trap(self, height: List[int]) -> int:
                N = len(height)
                if N <= 2:
                    return 0
                
                # 先从左往右
                Max = height[0]
                temp = [0] * N
                for i in range(1, N - 1):
                    if height[i] > Max:
                        Max = height[i]
                    else:
                        temp[i] = Max - height[i]
                
                Max = height[-1]
                for i in range(N - 2, -1, -1):
                    if height[i] > Max:
                        Max = height[i]
                        temp[i] = 0
                    else:
                        temp[i] = min(temp[i], Max - height[i])
                
                return sum(temp)
        ```

*   解题思路_双指针

    *   解题的依据和上述方法一样，就是判断一个位置左右两侧最大值和当前位置的大小关系，结算每个位置的水量最后求和
    *   左右指针分别指向首元素和结尾元素，移动两个元素中较小的一个，并结算移动后位置的水量，在指针移动的过程中要维护两个方向的最值

*   实现代码

    *   ```python
        class Solution:
            def trap(self, height: List[int]) -> int:
                N = len(height)
                if N <= 2:
                    return 0
        
                left = 0
                right = N - 1
                lMax = height[0]
                rMax = height[-1]
                temp = [0] * N
        
                while right - left > 1:
                    if height[left] < height[right]:
                        temp[left + 1] = max(0, lMax - height[left + 1])
                        lMax = max(lMax, height[left + 1])
                        left += 1
                    else:
                        temp[right - 1] = max(0, rMax - height[right - 1])
                        rMax = max(rMax, height[right - 1])
                        right -= 1
                
                return sum(temp)
        ```





---

## leetCode407 接雨水II

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/trapping-rain-water-ii/)

*   解题思路

    *   先将四周的点依次加入堆中去，同时带上自己的行列信息；
    *   维护一个遍历tempMax它表示的是当前墙最低点，墙的瓶颈
    *   从堆中弹出墙中最低点，看它能否让现有瓶颈变大`l:36`
    *   然后结算他的上下左右四个点，因为如果四个点存在且小于当前点，那么它们最多能接的水就是当前瓶颈 - 它们自身高度`l:48`，大于瓶颈则没水，水必定从瓶颈方向流走
    *   将结算完的点加入堆中去，直到每个点都处理即堆中为空

*   实现代码

    *   ```python
        class Solution:
            def trapRainWater(self, heightMap: List[List[int]]) -> int:
                M = len(heightMap[0]) # col
                N = len(heightMap)  # row
                dir = ((0, 1), (0, -1), (-1, 0), (1, 0))
                if N <= 2:
                    return 0
        
                import heapq
                heap = []
                # 标记是否处理过的数组
                used = [[False for j in range(M)] for i in range(N)]
        
                # tempMax表示是当前为单元格所处墙内的瓶颈
                tempMax = -1
        
                res = 0
                # 先将最外面的一圈放入heap中去(其实四个角没必要放)
                for j in range(M):
                    heap.append((heightMap[0][j], 0, j))
                    used[0][j] = True
                    heap.append((heightMap[N - 1][j], N - 1, j))
                    used[N - 1][j] = True
        
                for i in range(1, N - 1):
                    heap.append((heightMap[i][0], i, 0))
                    used[i][0] = True
                    heap.append((heightMap[i][M - 1], i, M - 1))
                    used[i][M - 1] = True
        
                heapq.heapify(heap)
        
                # 依次处理每个点
                while heap != []:
                    tHeight, x, y = heapq.heappop(heap)
                    if tHeight > tempMax:
                        tempMax = tHeight
                    
                    # 拓展当前点
                    for dx, dy in dir:
                        # 入堆的条件是，下标不越界且没被处理过
                        tx = x + dx
                        ty = y + dy
                        if tx <= 0 or tx >= N - 1 or  ty <= 0 or ty >= M - 1 or used[tx][ty] == True:
                            continue
                        if heightMap[tx][ty] < tempMax:
                            # 可以结算当前拓展点
                            res += (tempMax - heightMap[tx][ty])
                        used[tx][ty] = True
                        heapq.heappush(heap, (heightMap[tx][ty], tx, ty))
        
                return res
        ```





---

## leetCode15 三数之和

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/3sum/)

*   解题思路

    *   先将数组排序；然后定义一个指针从左往右遍历(为了去重所以与前面字符相同的跳过)，在当前指针往后找是否能凑出当前值相反数的两数和
    *   求两数和方法：双指针；因为可能出现多对结果，所找到后left += 1，right -= 1知道left == right

*   实现代码

    *   ```python
        class Solution:
            def threeSum(self, nums: List[int]) -> List[List[int]]:
                nums.sort()
                if nums[-1] < 0 or nums[0] > 0:
                    return []
                res = []
        
                def towSum(target, beg):
                    left = beg
                    right = len(nums) - 1
                    
                    while left < right:
                        if nums[left] + nums[right] + target == 0:
                            res.append([nums[left], target, nums[right]])
        
                            left += 1
                            while left < right and nums[left] == nums[left - 1]:
                                left += 1
                            right -= 1
                            while right > left and nums[right] == nums[right + 1]:
                                right -= 1
                            
                        elif nums[left] + nums[right] + target > 0:
                            right -= 1
                        else:
                            left += 1
                
                for i in range(len(nums)):
                    if i > 0 and nums[i] == nums[i - 1]:
                        continue
                    towSum(nums[i], i + 1)
        
                return res
        ```



---

## leetCode16 最接近的三数之和

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/3sum-closest/)

*   解题思路

    *   做法与三数之和相近，不同的是在判断当前组合是否足够接近目标值时需要求当前和和目标值的绝对值，注意去重和指针移动即可

*   实现代码

    *   ```python
        class Solution:
            def threeSumClosest(self, nums: List[int], target: int) -> int:
                import sys
                nums.sort()
                
        
                def towSum(tTarget, beg, tGap):
                    tRes = None
                    left = beg
                    right = len(nums) - 1
                    while left < right:
                        nowSum = nums[left] + nums[right]
                        nowGap = abs(tTarget - nowSum)
                        if tGap > nowGap:
                            tGap = nowGap
                            tRes = nowSum
            
                        if nowGap == 0:
                            return 0, nowSum
        
                        if nowSum > tTarget:
                            right -= 1
                            while right > left and nums[right] == nums[right + 1]:
                                right -= 1
                        else:
                            left += 1
                            while left < right and nums[left - 1] == nums[left]:
                                left += 1
        
                    return tGap, tRes
                    
        
                gap = sys.maxsize
                res = None
                for i in range(len(nums) - 2):
                    if i - 1 >= 0 and nums[i] == nums[i - 1]:
                        continue
                    tGap, tRes = towSum(target - nums[i], i + 1, gap)
                    if gap > tGap:
                        gap = tGap
                        res = tRes + nums[i]
                    if gap == 0:
                        res = target
                        break
                return res
        ```





---

## leetCode18 四数之和

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/4sum/)

*   解题思路

    *   思路和两数之和、三数之和一样

*   实现代码

    *   ```python
        class Solution:
            def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
                nums.sort()
                if len(nums) < 4:
                    return []
                N = len(nums)
                
                def towSum(tTarget, pre1, pre2, left):
                    
                    right = N - 1
                    lMove = False
                    rMove = False
        
                    while left < right:
                        if nums[left] + nums[right] == tTarget:
                            res.append([pre1, pre2, nums[left], nums[right]])
                            lMove = True
                            rMove = True
                        elif nums[left] + nums[right] > tTarget:
                            rMove = True
                        else:
                            lMove = True
        
                        if lMove:
                            left += 1
                            while left < right and nums[left] == nums[left - 1]:
                                left += 1
                            lMove = False
                        if rMove:
                            right -= 1
                            while right > left and nums[right] == nums[right + 1]:
                                right -= 1
                            rMove = False
        
                    return res
                
                def threeSum(tTarget, pre1, left):
                    for i in range(left, N - 2):
                        if i > left and nums[i] == nums[i - 1]:
                            continue
                        towSum(tTarget - nums[i], pre1, nums[i], i + 1)
                    return res
                
                res = []
                for i in range(N - 3):
                    if i > 0 and nums[i] == nums[i - 1]:
                        continue
                    threeSum(target - nums[i], nums[i], i + 1)
                
                return res
        ```













## leetCode26 删除有序数组中的重复项

-   问题描述
    -   [问题地址](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

-   解题思路

    -   快慢指针，快指针遍历数组，慢指针指向有效区的最后一个值；
    -   如果快指针的值和它之前的值不一样，那么就将这个值拓展到有效区

-   实现代码

    -   ```python
        class Solution:
            def removeDuplicates(self, nums: List[int]) -> int:
                if len(nums) == 1:
                    return 1
        
                slow = 0
                pre = nums[0]
                fast = 1
                while fast < len(nums):
                    if nums[fast] != pre:
                        nums[slow + 1] = nums[fast]
                        slow += 1
        
                    pre = nums[fast]
                    fast += 1
        
                return slow + 1
        ```









## leetCode27 移除元素

-   问题描述

    -   [问题地址](https://leetcode.cn/problems/remove-element/)

-   解题思路

    -   大致与26题一直；不同的是，因为要将删除的元素放在最后，所以right指向的是删除区域的最后一个位置；
    -   如果left的值需要删除就用这个值和删除区的下一个值交换，扩大删除区，此时left下标不动，因为换过来的值还没处理过

-   实现代码

    -   ```python
        class Solution:
            def removeElement(self, nums: List[int], val: int) -> int:
                left = 0
                right = len(nums)
        
                while left < right:
                    if nums[left] == val:
                        nums[left], nums[right - 1] = nums[right - 1], nums[left]
                        right -= 1
                    else:
                        left += 1
        
                return left
        ```

    -   

















## leetCode30 串联所有单词的子串

-   问题描述
    -   [问题地址](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

-   解题思路

    -   滑动窗口
    -   由题可知符合条件窗口的大小，就判断每个位置作为窗口开头是否合法
    -   因为每个元素的长度都相同，所以在一个窗口中，从左往右滑入元素长度的字符放入哈希表中
    -   最后比对当前窗口下的所有字符串是否和所需相同

-   实现代码

    -   ```python
        class Solution:
            def findSubstring(self, s: str, words: List[str]) -> List[int]:
                import collections
                
                step = len(words[0])
                need = collections.Counter(words)
                windowSize = len(words) * step
                res = []
        
        
                for left in range(0, len(s) - windowSize + 1):
                    tempS = s[left:left +  windowSize]
                    window = dict()
                    
                    right = 0
                    while right < len(tempS):
                        nowWord = tempS[right : right  +  step]
                        window[nowWord] = window.get(nowWord, 0) + 1
                        right += step
        
                    if window == need:
                        res.append(left)
        
                return res
        ```









---

## leetCode31 下一个排列

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/next-permutation/)

-   解题思路

    -   如果当前排列没有下一个排列，那么当前排列一定是递减的
    -   要想要当前排列变大，就要让后面一个较大的值和前面一个小于它的值交换
    -   但是又要变大的幅度最小，那么被交换的数字就必须要靠后
    -   那么就从右往左依次遍历，直到遇到第一个打破递增单调性的值，这个值就是要被替换的值，因为是在最右侧的导致当前排列较小的值，将它与它右侧与它最接近的大于它的值交换，然后让它后续的值全部升序
    -   因为它后面的值是递增的且交换后性质已然保留，所以将它们逆序即可

-   实现代码

    -   ```python
        class Solution:
            def nextPermutation(self, nums: List[int]) -> None:
                """
                Do not return anything, modify nums in-place instead.
                """
                if len(nums) == 1:
                    return 
                # 从右向左找到第一个打破单调性的值
                flag = False
                for i in range(len(nums) - 2, -1, -1):
                    if nums[i] < nums[i + 1]:
                        # 找到了需要进行交换的数
                        flag = True
                        break
        
                if flag:
                    # 找到了需要换的数
                    for j in range(len(nums) - 1, i, -1):
                        # 找到大于i位置的数且理它最近
                        if nums[j] > nums[i]:
                            nums[j], nums[i] = nums[i], nums[j]
                            
                            left = i + 1
                            right = len(nums) - 1
                            while left < right:
                                nums[left], nums[right] = nums[right], nums[left]
                                left += 1
                                right -= 1
        
                            break
                else:
                    nums = nums.reverse()
        ```




---

## leetCode33 搜索旋转排序数组

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

*   解题思路

    *   题目说明数组中不存在重复元素，且有序
    *   通过观察可以发现，即便在翻转了一次之后，在数组中任意位置截断，左右两侧都至少有一侧是有序的
    *   找到中点后判断哪一侧是有序的，再判断目标值是否在有序范围内，如果在则在有序侧继续二分，不在则在另一侧二分
    *   如果数组中可能出现重复元素，可能会出现Left、Right、mid指针所指向的元素值相同，无法判断哪一侧是有序的，这时就可以移动左右一侧的指针，直到三个指针的值不都相同(注意边界情况)；只要三个指针的值不都相同那么就可以判断出哪一侧有序

*   实现代码

    *   ```python
        class Solution:
            def search(self, nums: List[int], target: int) -> int:
                left = 0
                right = len(nums) - 1
        
                while left <= right:
                    mid = (left + right) // 2
                    if target == nums[mid]:
                        return mid
                    if nums[left] <= nums[mid]:
                        # 左侧有序
                        if target >= nums[left] and target < nums[mid]:
                            right = mid - 1
                        else:
                            left = mid + 1
                    else:
                        # 右侧有序
                        if nums[mid] < target and target <= nums[right]:
                            left = mid + 1
                        else:
                            right = mid - 1
        
                return -1
        ```





---

## leetCode81 搜索旋转排序数组 II

-   问题描述

    -   [问题地址](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

-   解题思路

    -   与33不同的是本题可能会出现重复值；如果重复值中为旋转中心，那么就不能直接判断出当前二分中心的左右两边那边有序
    -   解决办法就是如果left的值与right的值相等就移动其中一个边，直到两值不同或者碰到当前mid，碰到mid就在mid另一侧去二分`l:16`
    -   只要两边的值不相同就一定能判断出mid哪一边有序，通过有序性和target的大小确定下一次二分的范围

-   实现代码

    -   ```python
        class Solution:
            def search(self, nums: List[int], target: int) -> bool:
        
        
                left = 0
                right = len(nums) - 1
                while left <= right:
                    mid = (left + right) >> 1
                    if nums[mid] == target:
                        return True
                    
                    if nums[left] == nums[right]:
                        while left < mid and nums[left] == nums[right]:
                            left += 1
                        if left == mid:
                            left = mid + 1
                            continue
                    
                    if nums[left] <= nums[mid]:
                        # 左侧一定有序
                        if nums[left] <= target and target < nums[mid]:
                            right = mid - 1
                        else:
                            left = mid + 1
                        
                    elif nums[mid] <= nums[right]:
                        # 右侧一定有序
                        if nums[right] >= target and target > nums[mid]:
                            left = mid + 1
                        else:
                            right = mid - 1
                    else:
                        break
                return False
        ```









---

## leetCode34 在排序数组中查找元素的第一个和最后一个位置

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

-   解题思路_01

    -   二分思路
    -   要找到一个目标值最左或者最右的位置，那么当mid指向目标值后不能像不同二分查找一样 退出，而应该继续收缩区间尝试优化当前解
    -   求一个最左的位置，再求一个最右值

-   实现代码_01

    -   ```python
        class Solution:
            def searchRange(self, nums: List[int], target: int) -> List[int]:
                N = len(nums)
                if N == 0:
                    return [-1, -1]
        
                res = []
        
                # 找最左
                left = 0
                right = N - 1
                temp = -1
                while left <= right:
                    mid = (left + right) >> 1
                    if nums[mid] == target:
                        temp = mid
                        right = mid - 1
                    elif nums[mid] > target:
                        right = right - 1
                    else:
                        left = left + 1
        
                if temp == -1:
                    return [-1, -1]
                res.append(temp)
                left = 0
                right = N - 1
                while left <= right:
                    mid = (left + right) >> 1
                    if nums[mid] == target:
                        temp = mid
                        left = left + 1
                    elif nums[mid] > target:
                        right = right - 1
                    else:
                        left = left + 1
                res.append(temp)
        
                return res
        ```

-   解题思路_02

    -   重新定义left和right的含义；left表示小于等于target的范围中后的一个位置，初值赋为-1，right表示大于target的第一个位置，初值赋为数组长度；这样就能计算一个值最右侧的位置（需要判断是否存在）
    -   同理可以得到最左侧的位置

-   实现代码_02

    -   ```python
        class Solution:
            def searchRange(self, nums: List[int], target: int) -> List[int]:
                if len(nums) == 0:
                    return [-1, -1]
                
                left = -1
                right = len(nums)
              	
                # 注意循环条件
                while left + 1 < right:
                    mid = (left + right) >> 1
                    if nums[mid] >= target:
                        # 注意收缩区间
                        right = mid
                    else:
                        left = mid
                
                if right != len(nums) and nums[right] == target:
                    res1 = right
                else:
                    return [-1, -1]
                
                left = -1
                right = len(nums)
                while left + 1 < right:
                    mid = (left + right) >> 1
                    if nums[mid] <= target:
                        left = mid
                    else:
                        right = mid
                res2 = left
                return [res1, res2]
        ```







---

## leetCode35 搜索插入位置

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/search-insert-position/)

*   解题思路

    *   通过二分将数组分为两个区域，左边部分都是严格小于target的值，右侧是大于等于target的值
    *   最后返回左侧区间 + 1的位置；如果存在就是target出现的第一个下标(题目中说明了没有重复值所以无所谓第几个)，如果不存在，那么这个位置就是应该插入的位置

*   实现代码

    *   ```python
        class Solution:
            def searchInsert(self, nums: List[int], target: int) -> int:
                left = -1
                right = len(nums)
        
                while left + 1 < right:
                    mid = (left + right) >> 1
                    if nums[mid] == target:
                        return mid
                    
                    if nums[mid] < target:
                        left = mid
                    else:
                        right = mid
                return left + 1 
        ```





---

## leetCode69 x 的平方根 

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/sqrtx/)

*   解题思路

    *   因为指数函数有单调性，所以如果$x^2 > y^2 则 |x| > |y|$
    *   因为本题结果保留整数部分所以，就是正确答案最左边的一个整数
    *   所以每次都维护一个最右答案，如果正确答案就是整数就放回正确答案`l:11`
    *   如果当前mid的平方小于x那么此时的mid就有可能是最左的整数，记录下来
    *   注意边界条件

*   实现代码

    *   ```python
        class Solution:
            def mySqrt(self, x: int) -> int:
                if x <= 1:
                    return x
                left = 0
                right = x
                res = 0
        
                while left <= right:
                    mid = (left + right) // 2
                    if mid * mid == x:
                        return int(mid)
                    elif mid * mid < x:
                        res = int(mid)
                        left = int(mid) + 1
                    else:
                        right = int(mid) - 1
                return int(res)
        ```






---

## leetCode74 搜索二维矩阵

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/search-a-2d-matrix/)

*   解题思路_朴素算法

    *   借助堆
    *   此算法会超时

*   实现代码_朴素算法

    *   ```python
        class Solution:
            def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
                if target < matrix[0][0] or target > matrix[-1][-1]:
                    return False
                M = len(matrix)
                N = len(matrix[0])
        
                heap = []
                heap.append((matrix[0][0], 0, 0))
        
                while heap != []:
                    tempNum, x, y = heapq.heappop(heap)
                    if tempNum == target:
                        return True
                    elif tempNum > target:
                        return False
                    if x + 1 < M:
                        heapq.heappush(heap, (matrix[x + 1][y], x + 1, y))
                    if y + 1 < N:
                        heapq.heappush(heap, (matrix[x][y + 1], x, y + 1))
        
        
                return False
        ```

*   解题思路_二分

    *   因为数组整体存在单调性
    *   所以考虑二分；只要解决二维下标和一维下标之间的转换即可

*   实现代码

    *   ```python
            class Solution:
                def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
                    if target < matrix[0][0] or target > matrix[-1][-1]:
                        return False
                    M = len(matrix)
                    N = len(matrix[0])
        
                    
                    def NtoXY(n):
                        x = n // N
                        y = n % N 
                        return x, y
                    
                    left = 0
                    right = M * N - 1
                    
                    while left <= right:
                        mid = (left + right) >> 1
                        x, y = NtoXY(mid)
                        if matrix[x][y] == target:
                            return True
                        elif matrix[x][y] > target:
                            right = mid - 1
                        else:
                            left = mid + 1
        
                    return False
      ```








---

## leetCode75 颜色分类

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/sort-colors/)

*   解题思路

    *   同荷兰国旗
    *   如果能保证所有的0最后都在左边，所有的2都在有边，那么此时1一定都在中间
    *   定义两个指针，一个指向0范围的最后一个元素下标，初值为-1；另一个指向2范围的第一个元素下标，初值为len(nums)
    *   遍历整个数组，如果当前为位置的值为1那么就用它和0下标的下一个数交换(被交换来的数一定不会是2)，让0指针更新；如果为2就和2下标的前一个数字交换，更新2的下标，交换过来的数字不能确定，所以遍历指针这轮原地不更新，再次判断一次该位置

*   实现代码

    *   ```python
        class Solution:
            def sortColors(self, nums: List[int]) -> None:
                """
                Do not return anything, modify nums in-place instead.
                """
                zeroLine = -1
                towLine = len(nums)
                
                i = 0
                while i < towLine:
                    if nums[i] == 0:
                        nums[i], nums[zeroLine + 1] = nums[zeroLine + 1], nums[i]
                        zeroLine += 1
                    elif nums[i] == 2:
                        nums[i], nums[towLine - 1] = nums[towLine - 1], nums[i]
                        towLine -= 1
                        i -= 1
                    i += 1
        ```










---

## leetCode80 删除有序数组中的重复项 II

*   问题描述
    *   [问题地址](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

*   解题思路

    *   题目数组是升序的
    *   快慢指针，快指针遍历数组，慢指针指向有效区域的下一个位置
    *   如果遍历到的元素和有效区slow - 2位置不同那么当前值就要保留，将它移动到slow位置移动slow
    *   返回有效长度，就是当前slow的下标值

*   实现代码

    *   ```python
        class Solution:
            def removeDuplicates(self, nums: List[int]) -> int:
                if len(nums) <= 2:
                    return 2
        
        
                slow = 2
                fast = 2
                while fast < len(nums):
                    if nums[fast] != nums[slow - 2]:
                        nums[fast], nums[slow] = nums[slow], nums[fast]
                        slow += 1
                    fast += 1
                return slow
        ```








---

## leetCode88 合并两个有序数组

*   问题描述

    *   [问题地址](https://leetcode.cn/problems/merge-sorted-array/)

*   解题思路

    *   定义三个指针，其中一个用来从后往前遍历num1，其他两个分别指向num1,num2最后一位有效数字
    *   只要两个指针没有越界，就比较当前两个指针所指向的值的大小，将较大的放到遍历指针所指向的位置，更新指针位置
    *   退出之后其中一个指针依然指向有效数字，将它及其之前的所有数组依次放入遍历指针及其之前

*   实现代码

    *   ```python
        class Solution:
            def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
                """
                Do not return anything, modify nums1 in-place instead.
                """
                if n == 0:
                    return 
                if m == 0:
                    for i in range(n):
                        nums1[i] = nums2[i]
                    return
                
                pNow = m + n - 1
                p1 = m - 1
                p2 = n - 1
                while p1 >= 0 and p2 >= 0:
                    if nums1[p1] > nums2[p2]:
                        nums1[pNow] = nums1[p1]
                        p1 -= 1
                    else:
                        nums1[pNow] = nums2[p2]
                        p2 -= 1
                    pNow -= 1
                while p1 >= 0:
                    nums1[pNow] = nums1[p1]
                    p1 -= 1
                    pNow -= 1
        
                while p2 >= 0:
                    nums1[pNow] = nums2[p2]
                    p2 -= 1
                    pNow -= 1
        ```































---

## leetCode

*   问题描述
    *   [问题地址]()



