# 动态规划DP

[toc]



---







---

## 题

### 机器人走路

*   问题描述

    *   假设有排成一行的N个位置，记为1-N，N一定大于或等于2开始时机器人在其中的S位置上(S一定是1-N中的一个)

        如果机器人来到1位置，那么下一步只能往右来到2位置﹔

        如果机器人来到N位置，那么下一步只能往左来到N-1位置;

        如果机器人来到中间位置，那么下一步可以往左走或者往右走;

        规定机器人必须走K步，最终能来到A位置(A也是1~N中的一个)的方法有多少种给定四个参数N、S、K、A，返回方法数。

*   解题思路1 尝试
    1.   定义一个递归函数
    2.   基类为当步数为0
         *   如果步数为0当前的位置就是目的地 则找到一种方法返回；
         *   否则返回0
    3.   如果当前点为两个边界点
         *   为1点：那么它到目的地的方法数就是 2 到该点的方法数；递归调用2位置，并步数- 1
         *   为N点：同理；递归调用N - 1，步数- 1
    4.   如果为普遍点
         *   那么就要考虑两个相邻点的情况
         *   它的方法数为左、右边邻点到目的地的总和

*   实现代码

    *   ```python
        count = 0
        def func(N, S, K, A):
            global count
            '''
            N : 可以走动地范围
            S : 当前起始点
            K : 当前剩余的步数
            A : 目的地
            '''
            # base case
            print(f"({S}, {K})")
            count += 1
            if K == 0:
                if S == A:
                    return 1
                return 0 # 步数为0时 只有起点和终点重合才有一种方式.
            if S == 1:
                return func(N, 2, K - 1, A)
            elif S == N:
                return func(N, S - 1, K - 1, A)
            else:
                return func(N, S - 1, K - 1, A) + func(N, S + 1, K - 1, A)
        print(f"{'=' * 20}\n共{func(4, 2, 4, 4)}种走法")
        print(f"总处理次数:{count}")
        ```



*   优化思路1

    1.   创建一个记录表
         *   申请一个记录表; 表的列表示步数 [0, K], 行表示起点 范围[1, N]，-1表示该单元格没有被处理过
    2.   当每次调用函数时都查表；看当前调用所对应的单元格是否已经处理过
         *   如果已经处理过，怎么就返回对应单元格的值
         *   未处理过，就按上诉步骤处理，处理后将对应单元格赋值

*   实现代码

    *   ```python
        # 记忆存储
        N = 4
        S = 2
        A = 4
        K = 4
        # 申请一个记录表; 表的列表示步数 [0, K], 行表示起点 范围[1, N]
        # -1表示该单元格没有被处理过
        tMap = [[-1 for i in range(K + 1)] for j in range(N)]
        
        global count
        count = 0
        def func(N, S, K, A):
            global count
            if tMap[S - 1][K] != -1:
                return tMap[S - 1][K]
            # 以下代码是在该点没有处理过的情况下处理的
            print(f"({S}, {K})")
            count += 1
            res = 0
            if K == 0:
                if S == A:
                    res = 1
            elif S == 1:
                res = func(N, 2, K - 1, A)
            elif S == N:
                res = func(N, N - 1, K - 1, A)
            else:
                res = func(N, S - 1, K - 1, A) + func(N, S + 1, K - 1, A)
            tMap[S - 1][K] = res
            return res
            
        func(N, S, K, A)
        print(f"{'=' * 20}\n共{tMap[S - 1][K]}种走法")
        print(f"总处理次数:{count}")
        ```

*   优化后可以节省许多重复处理过的子问题





*   优化思路2
    *   直接生成一张完整的记录表，并填满该表
    *   更加尝试方法的代码，弄清楚每个单元格的依赖关系

*   实现代码

    *   ```python
        N = 4
        S = 2
        A = 4
        K = 4
        # 初始化一张记录表；表的列表示步数 [0, K], 行表示起点 范围[1, N]
        tMap = [[0 for i in range(K + 1)] for j in range(N)]
        
        # 初始化第一列的数据; 除了 A 行的单元格为1其余行为0; 
        # 对应代码
            # if K == 0:
            #     if S == A:
            #         res = 1
        tMap[A - 1][0] = 1
        
        # 开始填剩余单元格
        for j in range(1, K + 1):
            # 单元格依赖: 
            # 第一行的单元格依赖左下角的单元格
            # 对应代码
                # if S == 1:
                #   return func(N, 2, K - 1, A)
            # 最后一行的单元格依赖为左上角的单元格
            # 对应代码
                # elif S == N:
                #   return func(N, S - 1, K - 1, A)
            # 其余行单元格的依赖为当前单元格的左上角和左下角的和
            # 对应代码
                # return func(N, S - 1, K - 1, A) + func(N, S + 1, K - 1, A)
            tMap[0][j] = tMap[1][j - 1]
            for i in range(1, N - 1):
                tMap[i][j] = tMap[i - 1][j - 1] + tMap[i + 1][j - 1]
            tMap[N - 1][j] = tMap[N - 2][j - 1]
        
        print(tMap[S - 1][K])
        ```







---

### 拿牌博弈

*   问题描述

    *   给定一个整型数组arr，代表数值不同的纸牌排成一条线玩家A和玩家B依次拿走每张纸牌

        规定玩家A先拿，玩家B后拿

        但是每个玩家每次只能拿走最左或最右的纸牌玩家A和玩家B都绝顶聪明

        请返回最后获胜者的分数。

*   解题思路

    *   定义两个函数；
        *   一个先手函数
        *   一个后手函数
    *   先手函数中
        *   基类
            *   当只剩一张牌时，就拿这张牌
        *   普遍情况时
            *   情况1： 拿左边的牌 + 拿完后剩余牌后手拿的最大值
            *   情况2： 拿右边的牌 + 拿完后剩余牌后手拿的最大值
            *   返回两种情况中的较大值
        *   
    *   后手函数中
        *   基类
            *   当只剩一张牌时，就不拿 值为0
        *   普遍情况时
            *   情况1：对手走左边的牌；那么就在剩余牌中先手拿的最优解
            *   情况2：对手走右边的牌；那么就在剩余牌中先手拿的最优解
            *   返回两种情况中的较小值
            *   因为是对手先选，所以不可能选到最好情况 

*   实现代码

    ```python
    # 给定一个整型数组arr，代表数值不同的纸牌排成一条线玩家A和玩家B依次拿走每张纸牌
    # 规定玩家A先拿，玩家B后拿
    # 但是每个玩家每次只能拿走最左或最右的纸牌玩家A和玩家B都绝顶聪明
    # 请返回最后获胜者的分数。
    pokers = [5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 1, 7]
    
    def fFunc(L, R):
        if L == R:
            return pokers[L]
        r1 = pokers[L] + sFunc(L + 1, R)
        r2 = pokers[R] + sFunc(L, R - 1)
        return max(r1, r2)
    
    def sFunc(L, R):
        if L == R:
            return 0
        r1 = fFunc(L + 1, R)
        r2 = fFunc(L, R - 1)
        return min(r1, r2)
    
    fPlayerScore = fFunc(0, len(pokers) - 1)
    sPlayerScore = sum(pokers) - fPlayerScore
    
    print(f"先手玩家的最优分数为:{fPlayerScore}\n后手玩家的最优分数为:{sPlayerScore}")
    # sPlayerScore = sFunc(0, len(pokers) - 1)
    # print(sPlayerScore)
    ```





*   优化思路1

    *   生成两张记录表；分别记录先手的每个起点到终点的最优选择值,后手表同理
        *   表的长和宽都是[0, N]
    *   在每次调用函数时都查找所对应表的对应单元格是否已经处理过
        *   处理过直接返回单元格值
        *   否则；按正常步骤处理，处理完后将对应表的对应单元格赋值

*   实现代码

    *   ```
        # 存储
        pokers = [5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 1, 7]
        N = len(pokers) - 1
        # 生成两张记录表；分别记录先手的每个起点到终点的最优选择值,后手表同理
        # 表的长和宽都是[0, N]
        fMap = [[-1 for i in range(N + 1)] for j in range(N + 1)]
        sMap = [[-1 for i in range(N + 1)] for j in range(N + 1)]
        
        def fFunc(L, R):
            if fMap[L][R] != -1:
                return fMap[L][R]
            
            # 以下代码为当前单元格没有处理过时处理步骤
            if L == R:
                res = pokers[L]
            else:
                p1 = pokers[L] + sFunc(L + 1, R)
                p2 = pokers[R] + sFunc(L, R - 1)
                res = max(p1, p2)
            fMap[L][R] = res
            return res
        def sFunc(L, R):
            if sMap[L][R] != -1:
                return sMap[L][R]   
            if L == R:
                res = 0
            else:
                r1 = fFunc(L + 1, R)
                r2 = fFunc(L, R - 1)
                res = min(r1, r2)
        
            sMap[L][R] = res
            return res
        
        fPlayerScore = fFunc(0, len(pokers) - 1)
        sPlayerScore = sum(pokers) - fPlayerScore
        print(f"先手玩家的最优分数为:{fPlayerScore}\n后手玩家的最优分数为:{sPlayerScore}")
        ```





*   优化思路2

    *   生成两张表；并按依赖关系填满两张表

*   实现代码

    *   ```
        pokers = [5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 1, 7]
        N = len(pokers) - 1
        
        # 生成两张记录表；分别记录先手的每个起点到终点的最优选择值,后手表同理
        # 表的长和宽都是[0, N]
        fMap = [[-1 for i in range(N + 1)] for j in range(N + 1)]
        sMap = [[-1 for i in range(N + 1)] for j in range(N + 1)]
        
        # 开始填两张表
        
        # 两表的左上到右下的对角线即为 L == R 的情况
            # 先手表即为poker[L]
            # 后手表即为0
        for i in range(N):
            fMap[i][i] = pokers[i]
            sMap[i][i] = 0
        
        # 其他单元格的依赖关系
            # 当L > R时无意义即对角线以下的单元格两个表都不会用到
            # 先手表中非对角线的单元格依赖是 它在后手表中的相对位置  
            # 下面的单元格与poker[L]之和  和 左边单元格与pokers[R]之和 两者的较大值
            # 对应代码
                # p1 = pokers[L] + sFunc(L + 1, R)
                # p2 = pokers[R] + sFunc(L, R - 1)
                # res = max(p1, p2)
            # 后手表同样的逻辑推得
        
        for j in range(1, N + 1): # 从第一列开始
            col = j
            row = 0
            while col <= N:
                fMap[row][col] = max(pokers[row] + sMap[row + 1][col], pokers[col] + sMap[row][col - 1])
                sMap[row][col] = min(fMap[row + 1][col], fMap[row][col - 1])
                col += 1
                row += 1
        print(fMap[0][N])
        ```

