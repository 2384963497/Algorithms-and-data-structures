# 图





---

##术语

*   图(graph) 的定义
    *   图G记作G=<V,E>
        *   V: vertex 顶点集
        *   E: Eged 边集
        *   G1 = {V1, E1}
        *   V1 = {v1, v2, v3, ...}
        *   E1 = {(v1, v2), (v2, v3), ...}


*   有向图和无向图
    *   有向图
        *   边是有方向的; 用尖括号
        *   E1 = {<v1, v2>, <v2, v3>, ...}
    *   无向图
        *   边是无方向的; 用小括号
        *   E1 = {(v1, v2), (v2, v3), ...}
*   网
    *   边上所带的值成为权
    *   边上带权的图成为网
    *   可分为有向网和无向网
*   有向完全图
    *   图中任意两点都又两条相反的弧连接; n个顶点有n(n-1)条边

*   无向完全图
    *   任意两个点都有边直接相连
*   稠密图和稀疏图
    *   接近于完全图的图成为稠密图; 边数很少的图成为稀疏图
*   邻接和关联
    *   有变直接相邻的两个点互为邻接点； 两点之间的关系
        *   V1和V2有边相连 则 V1和V2互为邻接点
    *   连接两点的边称为两点的
        *   V1和V2有边相连 则 边(v1, v2)关联V1, v2

*   度, 入度, 出度
    *   度
        *   关联与某顶点V的边的数量
    *   入度
        *   以某顶点V为**终点**的有向边数量
    *   出度
        *   以某顶点V为**起点**的有向边数量
    *   有向图中顶点的度为出度和入度之和
    *   在边数为e的图中的度数和为2*e
*   路径相关
    *   路径
        *   多条边组成的序列
    *   路径的长度
        *   无权图中为路径上的边数; 带权图中为带权路径权的总和
    *   回路(环)
        *   起点和终点相同的路劲
    *   简单路劲
        *   **起点和终点可以相同**外其他的点顶点均不相同; 即其他顶点不重复走第二次
    *   简单回路(简单环)
        *   **起点和终点相同**外其他的点顶点均不相同; 即其他顶点不重复走第二次

*   连通图和强连通图
    *   连通图
        *   在无向图中；任意的两个点都能通过某个路劲到达则称图为连通图
    *   强连通图
        *   针对有限图的连通图
*   子图
    *   原图的一部分
*   连通分量
    *   极大的连通子图; 再任意加入一个顶点就不连通
*   强连通分量
    *   针对有向图的连通分量
*   极小连通分量
    *   一个极小连通分量再删除任意一条边, 图就不连通了
    *   技校连通分量是没有回路的

## ADT 图

*   邻接矩阵
    *   <img src="images/image-20221114094358636.png" alt="image-20221114094358636" style="zoom:50%;" />
    *   无向完全图的邻接矩阵是对称的; 在存储时可以进行压缩
    *   每个顶点的度 都是该行1的个数
    *   如果边是带权的则将图中的1改为对应权
    *   在有向邻接矩阵中; 行对应的1的个数是出度值，列对应的1的入度值
    *   特点
        *   不适合删除和插入顶点
        *   不适合存储稀疏图
        *   时间复杂度为$O(n^2)$

*   邻接表
    *   <img src="images/image-20221114114329871.png" alt="image-20221114114329871" style="zoom: 35%;" />
    *   将每个顶点的邻接点都记录在一个行中; 也可以储存权信息

*   图的ADT方式不止两种，有很多。

*   邻接表其中一种实现代码
    *   见下面狄克斯特拉算法↓



---

## 狄克斯特拉算法

*   在带权无向图中；给定一个点；输入该点到其他所有点的最短路径权值

*   解题思路

    1.    维护一个字典；key为目标点，value初始值设为None 不可达
    2.    从当前点开始，依次看它到邻接点的权值和起点到本身的权值之和是否小于到该点的原有的权值；小于则更新邻接点的值； 如果邻接点的值为None同样更新
    3.    完成后，从该点的路径中选择一个目标点未锁定，且权值最小的路径；
    4.    完成一个顶点的检测后将它锁定；依次执行上诉操作 直到图中每个点都遍历一次

*   实现代码

    *   ```python
        # 定义vertex类
        class Vertex():
            def __init__(self, value):
                self.value = value
                self.nexts = {}
            
            def addNext(self, to, weight = None):
                self.nexts[to] = weight
            
            def getNext(self):
                # return self.nexts.keys()
                return self.nexts.items()
        
        class Graph():
            def __init__(self):
                self.vertexs = []
                self.vertexValue = []
        
            def addVertex(self, value):
                tempVertex = Vertex(value)
                self.vertexValue.append(value)
                self.vertexs.append(tempVertex)
        
            def addEdge(self, From, to, weight = None):
                for i in self.vertexs:
                    if i.value == From:
                        i.addNext(to, weight)
                    if i.value == to:
                        i.addNext(From, weight)
        
            def getNexts(self, value):
                for i in self.vertexs:
                    if i.value == value:
                        return i.getNext()
        
            def getVertex(self, value):
                '''
                    通过所给value值 返回顶点的地址
                '''
                for i in self.vertexs:
                    if i.value == value:
                        return i
        
            def getVertexNum(self):
                return len(self.vertexValue)
        
            def Dij(self, begin):
                result = {}
                locked = []
                for i in self.vertexValue:  # 初始化  其余点到起点的距离都置为None
                    result[i] = None
                    if i == begin:          # 到自己的距离置为0
                        result[i] = 0
                
                # 最开始定义一个变量指向出发点
                tempVertex = self.getVertex(begin)
                locked.append(tempVertex.value)
        
                while len(locked) < self.getVertexNum():
                    minWeight = None
                    minNext = None
                    for i in tempVertex.nexts:
                        if (minWeight == None or minWeight > tempVertex.nexts[i]) and i not in locked:
                            minNext = i
                            minWeight = tempVertex.nexts[i]
                        if result[i] == None or result[i] > result[tempVertex.value] + tempVertex.nexts[i]:
                            result[i] = result[tempVertex.value] + tempVertex.nexts[i]
                    
                    # 选择一条权值最小的路径 继续以上操作
                    tempVertex = self.getVertex(minNext)
                    locked.append(tempVertex.value)
        
                return result
        
        
        if __name__ == '__main__':
            myGraph = Graph()
            myGraph.addVertex('A')
            myGraph.addVertex('B')
            myGraph.addVertex('C')
            myGraph.addVertex('D')
            myGraph.addVertex('E')
            myGraph.addVertex('F')
            myGraph.addEdge('A', 'B', 3)
            myGraph.addEdge('A', 'C', 19)
            myGraph.addEdge('A', 'D', 9)
            myGraph.addEdge('C', 'D', 7)
            myGraph.addEdge('C', 'B', 12)
            myGraph.addEdge('C', 'E', 14)
            myGraph.addEdge('E', 'F', 7777)
            myGraph.addEdge('E', 'B', 200)
            myGraph.addEdge('E', 'D', 20)
        
        
            result = myGraph.Dij('A')
            for i in result:
                print(f"A点到{i}的最短距离为{result[i]}")
            print("-"*30)
            result = myGraph.Dij('C')
            for i in result:
                print(f"C点到{i}的最短距离为{result[i]}")
        ```

    *   <img src="images/image-20221114210927546.png" alt="image-20221114210927546" style="zoom:50%;" />





































































---

## 单词

*   graph  图

*   vertex  顶点

*   matrix  矩阵







