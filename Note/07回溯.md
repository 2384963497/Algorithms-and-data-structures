#回溯

## 回溯思想

*   backtrack

*   回溯和递归一起出现，通常都在递归当中；

*   回溯是纯暴力搜索

*   回溯能解决的问题

    *   排列
    *   组合

    *   切割

    *   子集

    *   棋盘问题

*   实例代码

    *   ```python
        # 输出ABCDE的全排列
        
        def backtracking(str):
            global count
            if len(str) == len(l):
                print(str)
                count += 1
                return
            for i in l:
                if i not in str:
                    backtracking(str+i)
        
        if __name__ == '__main__':
            count = 0
            l = ['A', 'B', 'C', 'D', 'E']
            backtracking('')
            print(count)
        
        ```

*   回溯的思想是在尝试一种可能性后将尝试退回到之前的状态，并开始下一次尝试

*   回溯算法的模板

    *   ```python
        def backtracking():
        	if 条件：	#递归函数的基类
        		收集数据
        		return
        	for 处理元素集合：
        		处理节点
        		递归函数
        		节点回溯
        ```

*   回溯的剪枝

    *   加入一些判断条件使一些不可能的路径提前结束；达到提升常数级别的复杂度优化

---

## 例题

### leetCode77

*   问题描述
    *    给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
*   解题思路
    *   本题利用回溯思想解决的关键就是要确定正确的递归停止条件
    *   当长度不等于所要求的长度时就逐个开始尝试；尝试完当前数后回溯到之前开始下一次尝试
    *   `l:3` 如果写成`res.append(nowList)`则每次追加的都是nowList的地址；当nowList回溯时之前所记录的res中的数据也会被回溯；
        所以要写成`res.append(nowList[:])`

*   实现代码

    *   ```python
        def backtracking(startNum, nowList):
            if len(nowList) == k:
                res.append(nowList[:])
                return
            
            for i in range(startNum, n+1):
                nowList.append(i)
                backtracking(i + 1, nowList)
                nowList.pop()
        
        
        if __name__ == '__main__':
            n = int(input(""))
            k = int(input(""))
            res = []
            backtracking(1, list())
            print(res)
        ```

*   剪枝优化

    *   ```python
        for i in range(startNum, n+1):
                if n - i + len(nowList) + 1 < k:
                    break
                nowList.append(i)
                backtracking(i + 1, nowList)
                nowList.pop()
        ```

    *   `l:2-3`主要剪枝思想

        *   如果当前数字开始带n 一共有n-i+1个数字
        *   如果这个长度+前面已经尝试的长度 < 指定的长度
        *   则无需继续向下尝试；因为一定是尝试不出合法的组合
        *   例如 
            *   nowList=[1, 4, 5]  k = 6  n=7 那么当前个i即为6
            *   后面的长度最长只能尝试到5 所以可以终止尝试

### leetCode39

*   问题描述

    *   ```python
        # 给你一个 *无重复元素* 的整数数组 candidates 和一个目标整数 target ，
        # 找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，
        # 并以列表形式返回。你可以按 任意顺序 返回这些组合。
        # candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
        # 对于给定的输入，保证和为 target 的不同组合数少于 150 个。
        ```

*   实现代码

    *   ```python
        def backTracking(strat, nowList):
            if sum(nowList) == target:
                res.append(nowList[:])
                return
            elif sum(nowList) >= target:
                return  
            for i in range(strat, len(condidate)):
                if sum(nowList) + condidate[i] > target:
                    break
                nowList.append(condidate[i])
                backTracking(i, nowList)
                nowList.pop()
        if __name__ == '__main__':
            condidate = [5,3,2]
            target = 8
            condidate.sort()
            res = []
            backTracking(0, [])
            print(res)
        ```


---

###leetCode40

*   问题描述

    *   ```python
        # 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：
        # 只使用数字1到9
        # 每个数字 最多使用一次 
        # 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
        # https://leetcode.cn/problems/combination-sum-ii/description/
        ```

*   解题思路

    *   将他们排序之后；那么值两个值相同的元素就会在一起；且在第一个元素进行DFS时一定会包含后面相同元素的情况；
        所以在处理连续多个相同的元素是，去重就是只执行首个值，后面相同的值直接跳过`l14-15`

*   实现代码

    *   ```python
        class Solution:
            def combinationSum2(self, candidates: list[int], target: int) -> list[list[int]]:
                candidates.sort()  
                res = []
        
                def backTracking(ind, nowList):
                    if sum(nowList) == target:
                        res.append(res[:])
                        return
                    if sum(nowList) > target:
                        return
        
                    for i in range(ind, len(candidates)):
                        if i > ind and candidates[i] == candidates[i - 1]:
                            continue
                        nowList.append(candidates[i])
                        backTracking(i + 1, nowList)
                        nowList.pop
        
                backTracking(0, [])
                return res
        ```

